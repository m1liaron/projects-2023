
// Звісно, ось пояснення useEffect для 12-річної дитини з прикладом:
// useEffect - це спеціальний інструмент в React, який допомагає вам робити щось після того, 
// як ваш компонент був показаний на екрані. Подумайте про нього як про помічника, який робить щось після того, 
// як важлива робота вже виконана.

// Наприклад, уявімо, що ви робите сайт, на якому показується поточний час. Ви хочете, щоб час оновлювався а
// втоматично, щоб люди завжди бачили правильний час. Ви можете використовувати useEffect, щоб переконатися, що 
// час завжди актуальний.

// Ось приклад коду:


import React, { useState, useEffect } from 'react';

function Clock() {
  const [time, setTime] = useState(new Date());

  useEffect(() => {
    const interval = setInterval(() => {
      setTime(new Date());
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h1>The current time is:</h1>
      <h2>{time.toLocaleTimeString()}</h2>
    </div>
  );
}

export default Clock;


// Тут ми створюємо компонент Clock, який показує поточний час. Ми використовуємо useState для відстеження часу, 
// а useEffect для його щосекундного оновлення.

// Хук useEffect має два аргументи. Перший аргумент - це функція, яка виконує потрібну вам роботу. У нашому випадку 
// ми хочемо оновлювати час щосекунди, тому створюємо інтервал, який викликає setTime з поточним часом.

// Другий аргумент - це масив залежностей. Він вказує React, коли викликати функцію. У нашому випадку ми хочемо 
// викликати її один раз, коли компонент змонтовано (тобто показано на екрані), тому ми передаємо порожній масив як другий аргумент.

// Це гарантує, що функція setInterval буде викликана лише один раз, коли компонент буде вперше показано на екрані. 
// Якби ми не передали порожній масив, функція setInterval викликалася б кожного разу при повторному рендерингу 
// компонента, що сповільнило б роботу сайту і зробило б його менш адаптивним.